# 계산기



## 문자열 수식 계산의 일반적 방법

1. 중위 표기법의 수식을 후위 표기법으로 변경(스택)
2. 후위 표기법의 수식을 스택을 이용하여 계산

**중위 표기법**

: 연산자를 피연산자의 가운데 표기하는 방법

ex) A+B

**후위 표기법**

: 연산자를 피연산자 뒤에 표기하는 방법

ex) AB+

| 토큰 | isp  | icp  |
| ---- | ---- | ---- |
| )    | -    | -    |
| * /  | 2    | 2    |
| + -  | 1    | 1    |
| (    | 0    | 3    |



## 계산기 1

중위 표기법에서 후위 표기법으로의 변환

```python
( 6 + 5 * ( 2 - 8 ) / 2 )

stack = [ ( + * ( - ) / ) ]

stack >> ) 닫는 괄호가 나오면 여는 괄호가 나올때 까지 pop 
      >> / 가 나왔을 때, 같은 크기인 *까지 pop시키고 이후 연산처리

num = 6 5 2 8 - * / 2 +     #후위표기법 완성
```



## 계산기 2

후위 표기법으로 표현된 수식 계산

```python
6 5 2 8 - * 2 / +

앞에서부터 스택에 넣기
[6528] - :연산자 나오면 피연산자 두개 꺼냄
2 - 8 = -6 앞에꺼 또 불러옴
5 * -6 = -30 뒤에 숫자 나오면 수납 [6 -30 2]
-30 / 2 = -15
6 + -15 = -9

최종값  -9
```





# 백트래킹

: 해를 찾는 도중에 ‘막히면’ 되돌아가서 다시 해를 찾아가는 기법

백트래킹 기법은 최적화(optimization)문제와 결정(decision)문제를 해결할 수 있음



### 절차

1. 상태 공간 트리의 깊이 우선 검색을 실시
2. 각 노드가 유망한지를 점검
3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속함



### 백트래킹 vs 깊이우선탐색

- 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임(Prunning 가지치기)

- 깊이우선탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단

- 깊이우선탐색을 가하기에는 경우의 수가 너무 많음

  즉, N! 가지의 경우의 수를 가진 문제에 대해 깊이우선탐색을 가하면 당연히 처리 불가능한 문제

- 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우에는 여전히 지수함수 시간(Exponential Time)을 요하므오 처리불가능





## 백트래킹을 이용하여 순열 구하기

```python
def f(i, N):
    if i == N:
        print(bit)
    else:
        bit[i] = 1
        f(i+1, N)
        bit[i] = 0
        f(i+1, N)

A = [1,2,3,4,5,6,7,8,9,10]
bit = [0] * 10
f(0, 10)
```



### [연습문제] 원소의 합이 10인 부분집합 구하기

```python
#부분집합 1
#합이 10인 부분집합 구하기 #개수만 구함

def f(i, N):
    global ans
    global cnt                  #찾아본 횟수
    cnt+=1
    if i == N:
        s= 0                    #부분 집합의 합
        for i in range(N):
            if bit[i]:
                s += A[i]
        if s == 10:
            ans += 1            #부분집합의 합이 10인 경우의 수
    else:
        candidate = [0,1]
        for x in candidate:
            bit[i] = x
            f(i+1,N)

A = [1,2,3,4,5,6,7,8,9,10]
bit = [0] * 10
ans = 0
cnt = 0
f(0, 10)
print(ans, cnt)
```

```python
#변수를 함수에 포함해서 동일한 함수 만들면?
#부분집합2
#합이 10인 부분집합 구하기 #개수만 구함

def f(i, N, s, t):
    global  answer
    global cnt
    cnt += 1
    if i == N:                  #모든 원소가 고려된 경우
        if s == t:              #부분집합의 합이 t면
            answer += 1
        return
    else:
        f(i+1, N, s+A[i], t)    #A[i]가 포함된 경우
        f(i+1, N, s, t)         #A[i]가 포함되지 않은 경우

A = [1,2,3,4,5,6,7,8,9,10]
bit = [0] * 10
cnt = 0
answer = 0
f(0, 10, 0, 10)
print(answer, cnt)
```

```python
#합이 10인 부분집합 구하기
#집합 원소 모두 출력하기
def f(i, N):
    global  ans
    if i == N:
        s= 0                                   #부분 집합의 합
        for i in range(N):
            if bit[i]:
                s += A[i]
        if s == 10:
            ans += 1                           #부분집합의 합이 10인 경우의 수
            for i in range(N):
                if bit[i]:
                    print(A[i], end = ' ')
            print()
    else:
        bit[i] = 1
        f(i+1, N)
        bit[i] = 0
        f(i+1, N)

A = [1,2,3,4,5,6,7,8,9,10]
bit = [0] * 10
ans = 0
f(0, 10)
print(ans)
```

```python
#숫자가 커질 때, 조건을 추가하여 검색횟수를 줄임
'''
추가한 부분
elif s > t:
	return
'''

def f(i, N, s, t):
    global  answer
    global cnt
    cnt += 1
    if i == N:                   #모든 원소가 고려된 경우
        if s == t:               #부분집합의 합이 t면
            answer += 1
        return
    elif s > t:                  #추가 (횟수 줄일 수 있음)
        return
    else:
        f(i+1, N, s+A[i], t)     #A[i]가 포함된 경우
        f(i+1, N, s, t)          #A[i]가 포함되지 않은 경우

A = [1,2,3,4,5,6,7,8,9,10]
bit = [0] * 10
cnt = 0
answer = 0
f(0, 10, 0, 10)
print(answer, cnt)
```